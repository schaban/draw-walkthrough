<!doctype html>
<html lang="en-us">

<head>
	<meta charset="utf-8">
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
	<meta http-equiv="Pragma" content="no-cache">
	<meta http-equiv="Expires" content="0">
	<link rel="shortcut icon" href="favicon.ico">
	<title>Draw-Walkthrough: Overview</title>
	<link href="dw.css" rel="stylesheet">
</head>

<body>
	<table id="main_text"><tr><td>

	<div style="font-size: 90%">Overview&nbsp;&nbsp;|&nbsp;&nbsp;<a href="start.html"/>Home</a>&nbsp;&nbsp;<a href="symbol.html"/>&gt;&gt;</a></div>
	<hr><br>

	<table><tr>
	<td width="30%">
	On supported Unix-type OS (Linux variants, FreeBSD, OpenBSD)
	clone the repo,
	compile and run.
	</td>
	<td class="manicule">
		&nbsp;&nbsp;&#x261E;&nbsp;
		<br>
	</td>
	<td>
	&nbsp;<code>git clone --depth 1 https://github.com/schaban/draw-walkthrough.git<br>cd draw-walkthrough</br>./build.sh<br>./run.sh</code>
	</td>
	</tr></table>

	<br><br><br>

	<table><tr>
	<td>
	<a href="pic/obj_types.jpg"><img src="pic/obj_types.jpg" width="97%"></a>
	</td>
	<td class="manicule">
		&#x261C;&nbsp;
		<br><br><br><br><br><br><br><br><br><br><br>
	</td>
	<td>
	Scene displayed after compiling and running the sample program will
	look similar to what's shown on the left side of this image.
	<br>
	Conceptually this scene can be split into three distinct types of objects:
	<br>
	&nbsp;<b>A</b> - animated character, deformable model;<br>
	&nbsp;<b>B</b> - background stage, static model;<br>
	&nbsp;<b>C</b> - text message;<br>
	<br><br><br><br><br><br><br><br><br>
	</td>
	</tr></table>

	<br><br><br>
	<table>
	<tr>
	<td>
		<a href="pic/chr_scn.jpg"><img src="pic/chr_scn.jpg" width="80%"></a>
	</td>
	<td>
		<br><br><br>
		<a href="pic/chr_geo.jpg"><img src="pic/chr_geo.jpg" width="80%"></a>
	</td>
	<td>
		<br><br><br>
		<a href="pic/chr_wgt.jpg"><img src="pic/chr_wgt.jpg" width="80%"></a>
	</td>
	<td>
		<br><br><br>
		<a href="pic/chr_bat.jpg"><img src="pic/chr_bat.jpg" width="80%"></a>
	</td>
	</tr>
	<tr>
		<td>
			<div class="manicule">&#x261D;&#xFE0E;</div>
			Of these three types animated<br>
			character is the most complex.
		</td>
		<td>
			<div class="manicule">&#x261D;&#xFE0E;</div>
			Base geometry in rest position.
		</td>
		<td>
			<div class="manicule">&#x261D;&#xFE0E;</div>
			Weights and joints.
		</td>
		<td>
			<div class="manicule">&#x261D;&#xFE0E;</div>
			Batches.
		</td>
	</tr>
	</table>

	<br>
	<table><tr>
		<td>
			Regardless of what types of primitives<br>
			were used for modeling, the most common<br>
			representation for real-time rendering is a<br>
			set of points and how these points are<br>
			connected into triangles.<br>
			Points in this context are called <b>vertices</b><br>
			and connections are stored as <b>indices</b>.<br>
			<br>
			An animated character model is controlled<br>
			by a skeleton, a hierarchy of <b>joints</b>.<br>
			Additional <b>attributes</b> can be assigned<br>
			to vertices.<br>
			E.g. for a model animated by joints,<br>
			which joints and with what weight influence<br>
			a vertex is the type of information stored<br>
			in this manner.<br>
			<br>
			Additionaly, the whole list of triangles<br>
			comprising a model, can be split into<br>
			groups, called <b>batches</b>, based for example<br>
			on textures assigned to different parts.<br>
		</td>
		<td>
			<div class="manicule">&nbsp;&#x261E;</div>
			<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
		</td>
		<td>
			<a href="pic/chr_topo.jpg"><img src="pic/chr_topo.jpg" width="50%"></a>
		</td>
	</tr></table>

	<br><br><br><br>

	<table>
	<tr>
	<td>
		<a href="pic/stg_scn.jpg"><img src="pic/stg_scn.jpg" width="90%"></a>
	</td>
	<td>
		<br><br><br>
		<a href="pic/stg_geo.jpg"><img src="pic/stg_geo.jpg" width="80%"></a>
	</td>
	<td>
		<br><br><br>
		<a href="pic/stg_bat.jpg"><img src="pic/stg_bat.jpg" width="80%"></a>
	</td>
	</tr>
	<tr>
		<td>
			<div class="manicule">&#x261D;&#xFE0E;</div>
			Stage model is static, so there is<br>
			no need to deform or even move it,<br>
			so this object type is much simpler.
		</td>
		<td>
			<div class="manicule">&#x261D;&#xFE0E;</div>
			Only model geometry is needed,<br>
			no weights and joints.
		</td>
		<td>
			<div class="manicule">&#x261D;&#xFE0E;</div>
			But it's still split in separate<br>
			batches for drawing.
		</td>
	</tr>
	</table>

	<br><br><br>

	<table>
	<tr>
	<td>
		Text is the simplest type.<br>
		It depends on font geometry data,
		where each letter's shape represented as a set of triangles.<br>
		That is, each such shape is similar to a batch in model data.
		Complete message is diplayed by drawing its letters one by one.
		<br><br><br><br>
	</td>
	<td>
		<div class="manicule">&nbsp;&#x261E;</div>
		<br><br><br><br><br>
	</td>
	<td>
		<a href="pic/txt_geo.jpg"><img src="pic/txt_geo.jpg" width="50%"></a>
	</td>
	<td>
	</tr>
	</table>

	<br><br><br>

	<br>

	Rendering in this example is abstracted from a particular graphics API with the interface
	shown below,<br>
	declared in
	<a href="https://github.com/schaban/crosscore_dev/blob/main/src/draw.hpp">draw.hpp</a>:<br>
	<code>
struct Ifc {
	...

	void (*init)(const int shadowSize, cxResourceManager* pRsrcMgr, Font* pFont);
	void (*reset)();

	int (*get_screen_width)();
	int (*get_screen_height)();

	cxMtx (*get_shadow_bias_mtx)();

	void (*init_prims)(const uint32_t maxVtx, const uint32_t maxIdx);
	void (*prim_geom)(const PrimGeom* pGeom);

	void (*begin)(const cxColor& clearColor);
	void (*end)();

	void (*<b>batch</b>)(cxModelWork* pWk, const int ibat, const Mode mode, const Context* pCtx);
	void (*prim)(const Prim* pPrim, const Context* pCtx);
	void (*quad)(const Quad* pQuad);
	void (*<b>symbol</b>)(const Symbol* pSym);
};
	</code>

	<br>
	This document walks through a very basic implementation using OpenGL.<br>
	Initial code is in
	<a href="https://github.com/schaban/crosscore_dev/blob/main/src/draw_simple_ogl.cpp">draw_simple_ogl.cpp</a><br>
	The two highlighted calls in the above interface are what's necessary<br>
	to implement to display the sample scene:<br>
	<b>symbol</b> to draw the text, <b>batch</b> to render both types of models.<br>
	<br>
	<br>

	<table><tr>
	<td>
		<code style="width: 102%">./run.sh -draw:simple_ogl</code>
		<br><br><br>
	</td>
	<td class="manicule">
		&nbsp;&nbsp;&nbsp;&#x261C;&nbsp;
		<br><br><br>
	</td>
	<td>
		Launching the sample program like this<br>
		will select draw-interface implementation<br>
		from draw_simple_ogl.cpp.
		<br><br><br>
	</td>
	</tr></table>

	<hr>
	<div style="font-size: 90%">Overview&nbsp;&nbsp;|&nbsp;&nbsp;<a href="start.html"/>Home</a>&nbsp;&nbsp;<a href="symbol.html"/>&gt;&gt;</a></div>

	</td></tr></table><!-- main_text -->
</body>

</html>
